<!-- Row 1 -->

<!--
<div class="row">
-->
  <!-- Column 1 -->
<!--  <div class="col-lg-4">
    <h2>Business processes</h2>
    <p>
We present a method for verifying properties of time-aware business processes, 
that is, business processes where time constraints on the activities are 
explicitly taken into account.
Business processes are specified using an extension of the Business Process 
Modeling Notation (BPMN) and durations are defined by constraints over integer 
numbers.
The definition of the operational semantics is given by a set OpSem of 
constrained Horn clauses (CHCs). 
Our verification method consists of two steps. 
(Step 1) We specialize OpSem with respect to a given business process
and a given temporal property to be verified, whereby getting a set of CHCs 
whose satisfiability is equivalent to the validity of the given property. 
(Step 2) We use state-of-the-art solvers for CHCs to check the satisfiability
of such sets of clauses.
We have implemented our verification method using the VeriMAP transformation
system, and the Eldarica and Z3 solvers for CHCs.
</p>
<p>
  <a class="btn btn-primary" 
     href="http://arxiv.org/pdf/1608.02807v1.pdf" role="button" 
     target="_blank">View details &raquo;</a>
</p>
</div>
-->

<!-- Column 1 -->
<div class="col-lg-4">
<h2>Relational properties</h2>
<p>
We present a method for verifying relational program properties, that is, 
properties that relate the input and the output of two programs. 
Our verification method is parametric with respect to the definition of the 
operational semantics of the programming language in which the two programs 
are written. 
That definition of the semantics consists of a set Int of constrained Horn 
clauses (CHCs) that encode the interpreter of the programming language. 
Then, given the programs and the relational property we want to verify, 
we generate, by using Int, a set of constrained Horn clauses whose satisfiability 
is equivalent to the validity of the property. 
Unfortunately, state-of-the-art solvers for CHCs have severe limitations in 
proving the satisfiability, or the unsatisfiability, of such sets of clauses. 
We propose some transformation techniques that increase the power of CHC 
solvers when verifying relational properties. We show that these transformations, 
based on unfold/fold rules, preserve satisfiability. 
Through an experimental evaluation, we show that in many cases CHC solvers are 
able to prove the satisfiability (or the unsatisfiability) of sets of clauses 
obtained by applying the transformations we propose, whereas the same solvers 
are unable to perform those proofs when given as input the original, 
untransformed sets of CHCs.
</p>
<p>
<a class="btn btn-primary" 
   href="https://www.sci.unich.it/~deangelis/papers/DeAngelisFPP_SAS-16.pdf" 
   role="button" target="_blank">View details &raquo;</a>
</p>
</div>

<!-- Column 2 -->
<div class="col-lg-4">
  <h2>Verification conditions</h2>
<p>
We present a method for automatically generating verification conditions for a 
class of imperative programs and safety properties. Our method is parametric with 
respect to the semantics of the imperative programming language, as it specializes, 
by using unfold/fold transformation rules, a Horn clause interpreter that encodes 
that semantics.
</p>
<p>
We define a multi-step operational semantics for a fragment of the C language and 
compare the verification conditions obtained by using this semantics with those 
obtained by using a more traditional small-step semantics. The flexibility of the 
approach is further demonstrated by showing that it is possible to easily take 
into account alternative operational semantics definitions for modeling new 
language features. Finally, we provide an experimental evaluation of the method 
by generating verification conditions using the multi-step and the small-step 
semantics for a few hundreds of programs taken from various publicly available 
benchmarks, and by checking the satisfiability of these verification conditions 
by using state-of-the-art Horn clause solvers. These experiments show that 
automated verification of programs from a formal definition of the operational 
semantics is indeed feasible in practice.
</p>
<p>
<a class="btn btn-primary" 
   href="http://www.sci.unich.it/~deangelis/papers/2016-DFPP_PPDP15-journal.pdf" 
   role="button" target="_blank">View details &raquo;</a></p>
  </div>

<!-- Column 3 -->
<!--
<div class="col-lg-4">
  <h2>Array Manipulating Programs</h2>
<p>
The transformation of constraint logic programs (CLP programs) has been shown to 
be an effective methodology for verifying properties of imperative programs. 
By following this methodology, we encode the negation of a partial correctness 
property of an imperative program prog as a predicate incorrect defined by a CLP 
program T, and we show that prog is correct by transforming T into the empty 
program (and thus incorrect does not hold) through the application of semantics 
preserving transformation rules. We can also show that prog is incorrect by 
transforming T into a program with the fact incorrect (and thus incorrect does 
hold). Some of the transformation rules perform replacements of constraints that 
are based on properties of the data structures manipulated by the program prog. 
</p>
<p>
In this paper we show that Constraint Handling Rules (CHR) are a suitable formalism 
for representing and applying constraint replacements during the transformation of 
CLP programs. In particular, we consider programs that manipulate integer arrays 
and we present a CHR encoding of a constraint replacement strategy based on the 
theory of arrays. We also propose a novel generalization strategy for constraints 
on integer arrays that combines CHR constraint replacements with various 
generalization operators on integer constraints, such as widening and convex hull. 
Generalization is controlled by additional constraints that relate the variable 
identifiers in the imperative program prog and the CLP representation of their 
values. The method presented in this paper has been implemented and we have 
demonstrated its effectiveness on a set of benchmark programs taken from the literature. 
</p>
<p>
<a class="btn btn-primary" 
   href="http://www.sci.unich.it/~fioravan/papers/2015_DFPP_PPDP.pdf" 
   role="button" target="_blank">View details &raquo;
</a></p>
</div>
-->

<!-- Column 3 -->
<div class="col-lg-4">
  <h2>Iterated specialization</h2>
<p>
We present a method for verifying properties of imperative programs by using 
techniques based on the specialization of constraint logic programs (CLP). 
We consider a class of imperative programs with integer variables and we focus 
our attention on safety properties, stating that no error configuration can be 
reached from any initial configuration. 
We introduce a CLP program I that encodes the interpreter of the language and 
defines a predicate unsafe equivalent to the negation of the safety property 
to be verified. 
Then, we specialize the CLP program I with respect to the given imperative 
program and the given initial and error configurations, with the objective of 
deriving a new CLP program Isp that either contains the fact unsafe (and in 
this case the imperative program is proved unsafe) or contains no clauses with 
head unsafe (and in this case the imperative program is proved safe). 
If Isp enjoys neither of these properties, we iterate the specialization process 
with the objective of deriving a CLP program where we can prove unsafety or safety. 
During the various specializations we may apply different strategies for 
propagating information (either propagating forward from an initial configuration 
to an error configuration, or propagating backward from an error configuration 
to an initial configuration) and different operators (such as the widening and 
the convex hull operators) for generalizing predicate definitions. 
Each specialization step is guaranteed to terminate, but due to the 
undecidability of program safety, the iterated specialization process may not 
terminate. 
By an experimental evaluation carried out on a significant set of examples taken 
from the literature, we show that our method improves the precision of program 
verification with respect to state-of-the-art software model checkers.
</p>
<p>
<a class="btn btn-primary" 
   href="http://www.iasi.cnr.it/%7Eproietti/papers/2014_DFPP_SCP.pdf" 
   role="button" target="_blank">View details &raquo;
</a>
</p>
</div>

</div>
